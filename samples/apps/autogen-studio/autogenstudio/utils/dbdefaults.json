{
  "models": [
    {
      "model": "gpt-4",
      "api_key": "Your Azure API key here",
      "base_url": "Your Azure base URL here",
      "api_type": "azure",
      "api_version": "Your Azure API version here",
      "description": "Azure Open AI model configuration"
    },
    {
      "model": "gpt-4-turbo-preview",
      "description": "OpenAI model configuration"
    },
    {
      "model": "TheBloke/zephyr-7B-alpha-AWQ",
      "api_key": "EMPTY",
      "base_url": "http://localhost:8000/v1",
      "description": "Local model example with vLLM server endpoint"
    }
  ],
  "agents": [
    {
      "type": "agent",
      "description": "A user proxy agent that executes code.",
      "init_code": "agent = autogen.UserProxyAgent(path_to_oai_dir=oai_dir, **agent_spec.config.dict())",
      "config": {
        "name": "userproxy",
        "human_input_mode": "NEVER",
        "max_consecutive_auto_reply": 5,
        "system_message": "You are a helpful assistant.",
        "default_auto_reply": "TERMINATE",
        "llm_config": false,
        "code_execution_config": {
          "work_dir": null,
          "use_docker": false,
          "executor": "commandline-local"
        }
      }
    },
    {
      "type": "agent",
      "description": "A primary assistant agent that writes plans and code to solve tasks.",
      "init_code": "agent = autogen.AssistantAgent(path_to_oai_dir=oai_dir, **agent_spec.config.dict())",
      "skills": [
        {
          "title": "find_papers_arxiv",
          "description": "This skill finds relevant papers on arXiv given a query.",
          "content": "import os\nimport re\nimport json\nimport hashlib\n\n\ndef search_arxiv(query, max_results=10):\n    \"\"\"\n    Searches arXiv for the given query using the arXiv API, then returns the search results. This is a helper function. In most cases, callers will want to use 'find_relevant_papers( query, max_results )' instead.\n\n    Args:\n        query (str): The search query.\n        max_results (int, optional): The maximum number of search results to return. Defaults to 10.\n\n    Returns:\n        jresults (list): A list of dictionaries. Each dictionary contains fields such as 'title', 'authors', 'summary', and 'pdf_url'\n\n    Example:\n        >>> results = search_arxiv(\"attention is all you need\")\n        >>> print(results)\n    \"\"\"\n\n    import arxiv\n\n    key = hashlib.md5((\"search_arxiv(\" + str(max_results) + \")\" + query).encode(\"utf-8\")).hexdigest()\n    # Create the cache if it doesn't exist\n    cache_dir = \".cache\"\n    if not os.path.isdir(cache_dir):\n        os.mkdir(cache_dir)\n\n    fname = os.path.join(cache_dir, key + \".cache\")\n\n    # Cache hit\n    if os.path.isfile(fname):\n        fh = open(fname, \"r\", encoding=\"utf-8\")\n        data = json.loads(fh.read())\n        fh.close()\n        return data\n\n    # Normalize the query, removing operator keywords\n    query = re.sub(r\"[^\\s\\w]\", \" \", query.lower())\n    query = re.sub(r\"\\s(and|or|not)\\s\", \" \", \" \" + query + \" \")\n    query = re.sub(r\"[^\\s\\w]\", \" \", query.lower())\n    query = re.sub(r\"\\s+\", \" \", query).strip()\n\n    search = arxiv.Search(query=query, max_results=max_results, sort_by=arxiv.SortCriterion.Relevance)\n\n    jresults = list()\n    for result in search.results():\n        r = dict()\n        r[\"entry_id\"] = result.entry_id\n        r[\"updated\"] = str(result.updated)\n        r[\"published\"] = str(result.published)\n        r[\"title\"] = result.title\n        r[\"authors\"] = [str(a) for a in result.authors]\n        r[\"summary\"] = result.summary\n        r[\"comment\"] = result.comment\n        r[\"journal_ref\"] = result.journal_ref\n        r[\"doi\"] = result.doi\n        r[\"primary_category\"] = result.primary_category\n        r[\"categories\"] = result.categories\n        r[\"links\"] = [str(link) for link in result.links]\n        r[\"pdf_url\"] = result.pdf_url\n        jresults.append(r)\n\n    if len(jresults) > max_results:\n        jresults = jresults[0:max_results]\n\n    # Save to cache\n    fh = open(fname, \"w\")\n    fh.write(json.dumps(jresults))\n    fh.close()\n    return jresults\n",
          "file_name": "find_papers_arxiv",
          "examples": ""
        },
        {
          "title": "generate_images",
          "description": "This skill generates images from a given query using OpenAI's DALL-E model and saves them to disk.",
          "content": "from typing import List\nimport uuid\nimport requests  # to perform HTTP requests\nfrom pathlib import Path\n\nfrom openai import OpenAI\n\n\ndef generate_and_save_images(query: str, image_size: str = \"1024x1024\") -> List[str]:\n    \"\"\"\n    Function to paint, draw or illustrate images based on the users query or request. Generates images from a given query using OpenAI's DALL-E model and saves them to disk.  Use the code below anytime there is a request to create an image.\n\n    :param query: A natural language description of the image to be generated.\n    :param image_size: The size of the image to be generated. (default is \"1024x1024\")\n    :return: A list of filenames for the saved images.\n    \"\"\"\n\n    client = OpenAI()  # Initialize the OpenAI client\n    response = client.images.generate(model=\"dall-e-3\", prompt=query, n=1, size=image_size)  # Generate images\n\n    # List to store the file names of saved images\n    saved_files = []\n\n    # Check if the response is successful\n    if response.data:\n        for image_data in response.data:\n            # Generate a random UUID as the file name\n            file_name = str(uuid.uuid4()) + \".png\"  # Assuming the image is a PNG\n            file_path = Path(file_name)\n\n            img_url = image_data.url\n            img_response = requests.get(img_url)\n            if img_response.status_code == 200:\n                # Write the binary content to a file\n                with open(file_path, \"wb\") as img_file:\n                    img_file.write(img_response.content)\n                    print(f\"Image saved to {file_path}\")\n                    saved_files.append(str(file_path))\n            else:\n                print(f\"Failed to download the image from {img_url}\")\n    else:\n        print(\"No image data found in the response!\")\n\n    # Return the list of saved files\n    return saved_files\n\n\n# Example usage of the function:\n# generate_and_save_images(\"A cute baby sea otter\")\n",
          "examples": ""
        }
      ],
      "config": {
        "name": "primary_assistant",
        "llm_config": {
          "config_list": [
            {
              "model": "gpt-4-turbo-preview"
            }
          ],
          "temperature": 0.1,
          "timeout": 600,
          "cache_seed": null
        },
        "human_input_mode": "NEVER",
        "max_consecutive_auto_reply": 8,
        "system_message": "You are a helpful AI assistant. Solve tasks using your coding and language skills. In the following cases, suggest python code (in a python coding block) or shell script (in a sh coding block) for the user to execute. 1. When you need to collect info, use the code to output the info you need, for example, browse or search the web, download/read a file, print the content of a webpage or a file, get the current date/time, check the operating system. After sufficient info is printed and the task is ready to be solved based on your language skill, you can solve the task by yourself. 2. When you need to perform some task with code, use the code to perform the task and output the result. Finish the task smartly. Solve the task step by step if you need to. If a plan is not provided, explain your plan first. Be clear which step uses code, and which step uses your language skill. When using code, you must indicate the script type in the code block. The user cannot provide any other feedback or perform any other action beyond executing the code you suggest. The user can't modify your code. So do not suggest incomplete code which requires users to modify. Don't use a code block if it's not intended to be executed by the user. If you want the user to save the code in a file before executing it, put # filename: <filename> inside the code block as the first line. Don't include multiple code blocks in one response. Do not ask users to copy and paste the result. Instead, use 'print' function for the output when relevant. Check the execution result returned by the user. If the result indicates there is an error, fix the error and output the code again. Suggest the full code instead of partial code or code changes. If the error can't be fixed or if the task is not solved even after the code is executed successfully, analyze the problem, revisit your assumption, collect additional info you need, and think of a different approach to try. When you find an answer, verify the answer carefully. Include verifiable evidence in your response if possible. Reply 'TERMINATE' in the end when everything is done."
      }
    }
  ],
  "skills": [
    {
      "title": "fetch_profile",
      "description": "This skill fetches the text content from a personal website.",
      "content": "from typing import Optional\nimport requests\nfrom bs4 import BeautifulSoup\n\n\ndef fetch_user_profile(url: str) -> Optional[str]:\n    \"\"\"\n    Fetches the text content from a personal website.\n\n    Given a URL of a person's personal website, this function scrapes\n    the content of the page and returns the text found within the <body>.\n\n    Args:\n        url (str): The URL of the person's personal website.\n\n    Returns:\n        Optional[str]: The text content of the website's body, or None if any error occurs.\n    \"\"\"\n    try:\n        # Send a GET request to the URL\n        response = requests.get(url)\n        # Check for successful access to the webpage\n        if response.status_code == 200:\n            # Parse the HTML content of the page using BeautifulSoup\n            soup = BeautifulSoup(response.text, \"html.parser\")\n            # Extract the content of the <body> tag\n            body_content = soup.find(\"body\")\n            # Return all the text in the body tag, stripping leading/trailing whitespaces\n            return \" \".join(body_content.stripped_strings) if body_content else None\n        else:\n            # Return None if the status code isn't 200 (success)\n            return None\n    except requests.RequestException:\n        # Return None if any request-related exception is caught\n        return None\n",
      "examples": "",
      "file_name": "fetch_profile.py"
    },
    {
      "title": "generate_images",
      "description": "This skill generates images from a given query using OpenAI's DALL-E model and saves them to disk.",
      "content": "from typing import List\nimport uuid\nimport requests  # to perform HTTP requests\nfrom pathlib import Path\n\nfrom openai import OpenAI\n\n\ndef generate_and_save_images(query: str, image_size: str = \"1024x1024\") -> List[str]:\n    \"\"\"\n    Function to paint, draw or illustrate images based on the users query or request. Generates images from a given query using OpenAI's DALL-E model and saves them to disk.  Use the code below anytime there is a request to create an image.\n\n    :param query: A natural language description of the image to be generated.\n    :param image_size: The size of the image to be generated. (default is \"1024x1024\")\n    :return: A list of filenames for the saved images.\n    \"\"\"\n\n    client = OpenAI()  # Initialize the OpenAI client\n    response = client.images.generate(model=\"dall-e-3\", prompt=query, n=1, size=image_size)  # Generate images\n\n    # List to store the file names of saved images\n    saved_files = []\n\n    # Check if the response is successful\n    if response.data:\n        for image_data in response.data:\n            # Generate a random UUID as the file name\n            file_name = str(uuid.uuid4()) + \".png\"  # Assuming the image is a PNG\n            file_path = Path(file_name)\n\n            img_url = image_data.url\n            img_response = requests.get(img_url)\n            if img_response.status_code == 200:\n                # Write the binary content to a file\n                with open(file_path, \"wb\") as img_file:\n                    img_file.write(img_response.content)\n                    print(f\"Image saved to {file_path}\")\n                    saved_files.append(str(file_path))\n            else:\n                print(f\"Failed to download the image from {img_url}\")\n    else:\n        print(\"No image data found in the response!\")\n\n    # Return the list of saved files\n    return saved_files\n",
      "examples": "from skills import generate_and_save_images\n\nfilenames = generate_and_save_images(\"A cute baby sea otter\")\nprint(filenames)\n",
      "file_name": "generate_images.py"
    },
    {
      "title": "send_command_to_coding_assistant",
      "description": "Executes various commands through a coding assistant, supporting operations like code management, version control, testing, and more. Designed for versatility in coding tasks.",
      "content": "from typing import Optional\nfrom autogenstudio.codingassistanceservice import CodingAssistantService\n\ndef send_command_to_coding_assistant(\n    assistant_name: str,\n    command: str,\n    args: Optional[str] = None,\n    gh_remote_url: Optional[str] = None,\n    description: Optional[str] = None,\n    private: Optional[bool] = None\n) -> str:\n    \"\"\"\n    Executes commands via a coding assistant. Enables diverse coding operations including reviews, fixes, and version control.\n\n    Args:\n        assistant_name (str): Coding assistant identifier.\n        command (str): Command to execute.\n        args (Optional[str]): Command arguments.\n        gh_remote_url (Optional[str]): GitHub URL for initial setup.\n        description (Optional[str]): Repo description.\n        private (Optional[bool]): Repo privacy setting.\n\n    Returns:\n        str: JSON-formatted command execution result.\n\n    Commands:\n        - 'cmd_clear': Clears console. No args. \n        - 'cmd_ls': Lists directory files. No args.\n        - 'cmd_undo': Undoes last operation. No args.\n        - 'cmd_diff': Shows diffs. No args.\n        - 'cmd_tokens': Displays token usage. No args.\n        - 'get_repo_map': Retrieves repo mapping. No args.\n        - 'cmd_message': \"Review and fix code.\" (natural language query)\n        - 'cmd_git': \"pull\" (git command)\n        - 'cmd_run': \"echo 'Hello'\" (shell command)\n        - 'cmd_pr': \"Feature X implementation\" (PR body)\n        - 'show_file': \"/path/to/file.py\" (file path)\n\n    \"\"\"\n    return CodingAssistantService.send_command_to_coding_assistant(assistant_name, command, args, gh_remote_url, description, private)",
      "examples": "from skills import send_command_to_coding_assistant\n\nresponse = send_command_to_coding_assistant('assistant_name', 'cmd_message', 'Review and fix code.')\nprint(response)\n",
      "file_name": "send_command_to_coding_assistant.py"
    },          
    {
      "title": "fetch_json",
      "description": "Simplifies HTTP GET or POST requests for JSON data retrieval or submission, utilizing AgentService for execution. Ideal for interactions with RESTful APIs.",
      "content": "from autogenstudio.agentservice import AgentService\n\n\ndef fetch_json(url, payload=None, method='GET'):\n    \"\"\"\n    Simplifies fetching or submitting JSON data via HTTP GET or POST, leveraging AgentService. Supports versatile applications in data retrieval or API interactions.\n\n    Args:\n        url (str): Target URL for the JSON data.\n        payload (dict, optional): Payload for POST requests.\n        method (str): 'GET' or 'POST' HTTP method.\n\n    Returns:\n        dict: JSON response as a dictionary.\n\n    Example:\n        # GET data\n        >>> from skills import fetch_json\n        >>> response = fetch_json('https://api.example.com/data')\n        >>> print(response)\n        # POST data\n        >>> from skills import fetch_json\n        >>> response = fetch_json('https://api.example.com/submit', payload={'key': 'value'}, method='POST')\n        >>> print(response)\n    \"\"\"\n    return AgentService.fetch_json(url, payload, method)\n",
      "examples": "from skills import fetch_json\n\n# GET data\nresponse = fetch_json('https://api.example.com/data')\nprint(response)\n\n# POST data\nresponse = fetch_json('https://api.example.com/submit', payload={'key': 'value'}, method='POST')\nprint(response)\n",
      "file_name": "fetch_json.py"
    },
    {
      "title": "upsert_skill",
      "description": "This skill facilitates creating or updating a skill within the system. It allows for the specification or modification of a skill's title, content, and file name. The operation updates details of existing skills or initializes new skills based on the provided parameters.",
      "content": "from typing import Optional\nfrom autogenstudio.agentservice import AgentService\n\n\ndef upsert_skill(\n    id: Optional[str] = None,\n    title: Optional[str] = None,\n    content: Optional[str] = None,\n    examples: Optional[str] = None\n    file_name: Optional[str] = None\n) -> str:\n    \"\"\"\n    Creates or updates a skill configuration. If an ID is provided, the skill with that ID is updated; otherwise, a new skill is created.\n\n    Args:\n        id (Optional[str]): The unique identifier for the skill to be updated. For a new skill, this should be None.\n        title (Optional[str]): The title of the skill.\n        content (Optional[str]): The detailed code or instructions that comprise the skill.\n        examples (Optional[str]): Python code examples using the skill. To use the skill doesn't require re-defining it by consuming agent, it needs to be imported from skills ie: 'from skills import read_file'.\n        file_name (Optional[str]): The name of the file associated with the skill.\n        description (Optional[str]): The description of the skill. Used to discover via semantic search, so describe the skill fully.\n\n    Returns:\n        str: A JSON-formatted string indicating the success or failure of the operation. It contains either the details of the updated skill or an error message.\n    \"\"\"\n    return AgentService.upsert_skill(id, title, content, examples, file_name, description)\n",
      "examples": "from skills import upsert_skill\n\nresponse = upsert_skill(\nid=None,\ntitle='JSON Parser',\ncontent='import json\\n\\ndef parse_json(data):\\n    return json.loads(data)',\nfile_name='json_parser.py',\ndescription='A skill for parsing JSON data.',\nexamples='from skills import parse_json\\n\\njson_data = \\'{\\\"key\\\": \\\"value\\\"}\\'\\nresult = parse_json(json_data)\\nprint(result)'\n)\nprint(response)\n# Success\n{'status': 'true', 'message': 'Skill upserted successfully', 'data': {'id': 'skill_id', 'title': 'JSON Parser', 'file_name': 'json_parser.py', 'description': 'A skill for parsing JSON data.'}}\n# Error\n{'status': 'false', 'message': 'Error occurred while upserting skill: <Error Detail>', 'data': ''}",
      "file_name": "upsert_skill.py"
    },
    {
      "title": "manage_agent_skills",
      "description": "Updates an agent's skills by adding or removing them based on specified actions and skill IDs, ensuring the agent's capabilities are accurately maintained. You can discover skills to find which ones to add.",
      "content": "from typing import List\nfrom autogenstudio.agentservice import AgentService\n\ndef manage_agent_skills(agent_id: str, skill_ids: List[str], action: str) -> str:\n    \"\"\"\n    Updates an agent's skill set by adding or removing skills. This function facilitates dynamic skill management for an agent.\n\n    Args:\n        agent_id (str): Identifier of the agent.\n        skill_ids (List[str]): UUIDs of the skills to modify.\n        action (str): 'add' to include or 'remove' to exclude skills.\n\n    Returns:\n        str: JSON string indicating operation success or failure, with agent details or error message.\n    \"\"\"\n    return AgentService.manage_agent_skills(agent_id, skill_ids, action)\n",
      "examples": "from skills import manage_agent_skills\n\n# Add skill\nresponse = manage_agent_skills('123e4567-e89b-12d3-a456-426614174000', ['456e567f-e89c-12d3-a457-426614174000'], 'add')\nprint(response)\n# Success\n{'status': 'true','message': 'Agent upserted successfully','data': [{'type': 'agent_type','config': {'name': 'Agent Name'},'id': 'agent_id_1', 'skills': [{'title': 'Skill Title','id': 'skill_id', 'description': 'Skill Description','file_name': 'skill_file.py'}],'description': 'Agent description'}]}\nprint(response)\n# Remove skill\nresponse = manage_agent_skills('123e4567-e89b-12d3-a456-426614174000', ['789f6780-e89d-12d3-a458-426614174000'], 'remove')\n# Success\n{'status': 'true','message': 'Agent upserted successfully','data': [{'type': 'agent_type','config': {'name': 'Agent Name'},'id': 'agent_id_1', 'skills': [{'title': 'Skill Title','id': 'skill_id', 'description': 'Skill Description','file_name': 'skill_file.py'}],'description': 'Agent description'}]}\n# Error\n{'status': 'false','message': 'Error occurred while upserting agent: <Error Detail>','data': ''}\n",
      "file_name": "manage_agent_skills.py"
    }, 
    {
      "title": "upsert_agent",
      "description": "Enables creation or update of an agent, including its name, system message, and description. Suitable for managing agent details and capabilities within the system.",
      "content": "from typing import Optional\nfrom autogenstudio.agentservice import AgentService\n\n\ndef upsert_agent(\n    id: Optional[str] = None,\n    name: Optional[str] = None,\n    msg: Optional[str] = None,\n    description: Optional[str] = None\n) -> str:\n    \"\"\"\n    Manages an agent's configuration by creating a new agent or updating an existing one based on provided identifiers and information.\n\n    Args:\n        id (Optional[str]): Unique ID for the agent (None for new agents).\n        name (Optional[str]): Agent's name.\n        msg (Optional[str]): System message for the agent.\n        description (Optional[str]): Agent's purpose and functionality.\n\n    Returns:\n        JSON string with operation outcome, including updated agent details or an error message.\n    \"\"\"\n    return AgentService.upsert_agent(id, name, msg, description)\n",
      "examples": "from skills import upsert_agent\n\nresponse = upsert_agent(id=None, name='Task Assistant', msg='Assist with various tasks.', description='An assistant designed to help with a variety of tasks.')\nprint(response)\n# Success\n{'status': 'true','message': 'Agent upserted successfully','data': [{'type': 'agent_type','config': {'name': 'Agent Name'},'id': 'agent_id_1', 'skills': [{'title': 'Skill Title','id': 'skill_id', 'description': 'Skill Description','file_name': 'skill_file.py'}],'description': 'Agent description'}]}\n",
      "file_name": "upsert_agent.py"
    },   
    {
      "title": "discover_entities",
      "description": "Enables dynamic discovery of skills, agents, and workflows using natural language queries. Utilizes semantic search technology to find the most relevant entities across different domains, facilitating enhanced integration and utilization of capabilities.",
      "content": "from typing import Dict, List, Optional\nfrom autogenstudio.agentservice import AgentService\n\nclass DiscoverEntities:\n    def __init__(self):\n        \"\"\"Initializes the DiscoverEntities for discovering skills, agents, and workflows.\"\"\"\n        pass\n\n    def discover_skills(self, queries: List[str]) -> Dict[str, List[str]]:\n        return AgentService.discover_services('skills', queries)\n\n    def discover_agents(self, queries: List[str]) -> Dict[str, List[str]]:\n        return AgentService.discover_services('agents', queries)\n\n    def discover_workflows(self, queries: List[str]) -> Dict[str, List[str]]:\n        return AgentService.discover_services('workflows', queries)\n",
      "examples": "from skills import DiscoverEntities\n\ndiscover_entities = DiscoverEntities()\n\n# Discover entities\nskills_result = discover_entities.discover_skills(['how to parse JSON', 'image processing with Python'])\nprint('Skills:', skills_result)\n\n# Discover agents\nagents_result = discover_entities.discover_agents(['task automation', 'data analysis'])\nprint('Agents:', agents_result)\n\n# Discover workflows\nworkflows_result = discover_entities.discover_workflows(['gaming information', 'travel advising services'])\nprint('Workflows:', workflows_result)\n",
      "file_name": "discover_entities.py"
    },
    {
      "title": "session_management",
      "description": "Facilitates managing sessions for workflows, enabling tasks delegation and information exchange across sessions. Supports obtaining target sessions and messaging between sessions.",
      "content": "from typing import Optional\nfrom autogenstudio.agentservice import AgentService\n\nclass SessionManagementSkill:\n    def __init__(self, current_session_id: str):\n        \"\"\"Initializes the SessionManagementSkill with the current session ID for managing session-related actions. Sessions instantiate workflows running agents through LLM inference, retaining scope across workflow inferences within a session. Each session is independent.\"\"\"\n        self.current_session_id = current_session_id\n\n    def get_target_session(self, workflow_id: str, new_session: Optional[bool] = None) -> str:\n        \"\"\"Obtains a target session ID for a specified workflow, potentially creating a new session based on the provided parameters.\n\n        Args:\n            workflow_id (str): The unique identifier of the workflow for which a target session is desired.\n            new_session (Optional[bool]): Determines whether a new session should be created for this workflow. If True, a new session is created; if False or omitted, an existing session is reused if available.\n\n        Returns:\n            str: JSON response containing the target session ID or an error message.\"\"\"\n        return AgentService.get_target_session(workflow_id, self.current_session_id, new_session)\n\n    def send_message_to_target_session(self, target_session_id: str, message_content: str) -> str:\n        \"\"\"Sends a message from the current session to a target session, facilitating communication and task delegation across sessions.\n\n        Args:\n            target_session_id (str): The session ID of the target session to which the message is to be sent.\n            message_content (str): The content of the message to be sent.\n\n        Returns:\n            str: JSON response from the target session or an error message.\"\"\"\n        return AgentService.send_message_to_target_session(self.current_session_id, target_session_id, message_content)\n",
      "examples": "from skills import SessionManagementSkill\n\n# Initialize the session management skill with the current session ID\nsession_management_skill = SessionManagementSkill(current_session_id='your-session-id-here')\n\n# Get a target session ID for workflow delegation\ntarget_session_response = session_management_skill.get_target_session('workflow_id_here', new_session=True)\nprint('Target Session Response:', target_session_response)\n\n# Send a message to the target session for communication\nmessage_response = session_management_skill.send_message_to_target_session('target_session_id_here', 'Message content here.')\nprint('Message Response:', message_response)\n",
      "file_name": "session_management.py"
    },    
    {
      "title": "web_surf",
      "description": "Enables agents to perform web surfing actions such as informational and navigational searches, visit specific pages, scroll up or down on the current page, answer questions from page content, and summarize web pages.",
      "content": "from typing import Optional\nfrom autogenstudio.websurferservice import WebSurferService\n\nclass WebSurfSkill:\n    def __init__(self, current_session_id: str):\n        \"\"\"Initializes the Web Surf skill with the current session ID for web surfing actions. IMPORTANT: If a relevant category applies for a search then use it. Both search engine types are great, google is a bit more expensive but offers category searches. If you don't find an ideal answer with one engine try the other and also try with different and also try different search queries.\"\"\"\n        self.current_session_id = current_session_id\n\n    def informational_search(self, query: str, search_engine: str = 'bing', category: str = 'search') -> str:\n        \"\"\"Performs a web search query and returns the results. Optional filters for search engine and category are available.\n        Args:\n            query (str): The search query to perform.\n            search_engine (str): [Optional] The search engine to use, 'bing' or 'google'. Defaults to 'bing'.\n            category (str): [Optional] The category to filter the search. Options include 'news', 'places', 'images', 'search', 'videos', 'shopping', 'sports', 'events'. Defaults to 'search'. Usually use with google.\n        Returns:\n            str: The search results in JSON format.\"\"\"\n        return WebSurferService.informational_search(self.current_session_id, query, search_engine, category)\n\n    def navigational_search(self, query: str, search_engine: str = 'bing', category: str = 'search') -> str:\n        \"\"\"Same as informational_search, conducts a web search query but navigates immediately to the top result, similar to the 'I'm Feeling Lucky' feature.\n        Args:\n            query (str): The search query to perform.\n            search_engine (str): [Optional] Same as informational_search.\n            category (str): [Optional] Same as informational_search.\n        Returns:\n            str: The top search result URL.\"\"\"\n        return WebSurferService.navigational_search(self.current_session_id, query, search_engine, category)\n\n    def visit_page(self, url: str) -> str:\n        \"\"\"Visits a webpage at the given URL and returns its text content.\n        Args:\n            url (str): The URL of the webpage to visit.\n        Returns:\n            str: The text content of the webpage.\"\"\"\n        return WebSurferService.visit_page(self.current_session_id, url)\n\n    def page_up(self) -> str:\n        \"\"\"Scrolls the viewport UP one page-length in the current webpage and returns the new viewport content.\n        Returns:\n            str: The content of the new viewport after scrolling up.\"\"\"\n        return WebSurferService.page_up(self.current_session_id)\n\n    def page_down(self) -> str:\n        \"\"\"Scrolls the viewport DOWN one page-length in the current webpage and returns the new viewport content.\n        Returns:\n            str: The content of the new viewport after scrolling down.\"\"\"\n        return WebSurferService.page_down(self.current_session_id)\n\n    def answer_from_page(self, question: Optional[str] = None, url: Optional[str] = None) -> str:\n        \"\"\"Uses AI to read the page and directly answer a given question based on the content, or summarize the page if no question is provided.\n        Args:\n            question (Optional[str]): The question to answer, defaults to summarizing the current page.\n            url (Optional[str]): The URL of the page, defaults to the current page if not provided.\n        Returns:\n            str: The direct answer or summary of the page content.\"\"\"\n        return WebSurferService.answer_from_page(self.current_session_id, question, url)\n\n    def summarize_page(self, url: Optional[str] = None) -> str:\n        \"\"\"Uses AI to summarize the content found at a given URL or the current page if no URL is provided.\n        Args:\n            url (Optional[str]): The URL of the page to summarize, defaults to the current page if not provided.\n        Returns:\n            str: The summary of the page content.\"\"\"\n        return self.answer_from_page(question=None, url=url)\n",
      "examples": "from skills import WebSurfSkill\n\n# Initialize the web surfing skill with the current session ID\nweb_surf_skill = WebSurfSkill(current_session_id='your-session-id-here')\n\n# Perform an informational search\ninfo_search_results = web_surf_skill.informational_search(query='latest tech news', search_engine='google', category='news')\nprint(info_search_results)\n\n# Perform a navigational search\nnavigational_result = web_surf_skill.navigational_search(query='OpenAI website', search_engine='bing')\nprint(navigational_result)\n\n# Visit a specific page\npage_content = web_surf_skill.visit_page(url='https://www.wikipedia.org')\nprint(page_content)\n\n# Scroll up on the current page\npage_up_content = web_surf_skill.page_up()\nprint(page_up_content)\n\n# Scroll down on the current page\npage_down_content = web_surf_skill.page_down()\nprint(page_down_content)\n\n# Answer a question from the current page content\nanswer = web_surf_skill.answer_from_page(question='What is the capital of France?')\nprint(answer)\n\n# Summarize the content of a specific page\nsummary = web_surf_skill.summarize_page(url='https://www.example.com/article')\nprint(summary)\n",
      "file_name": "web_surf.py"
    },
    {
      "title": "zapier_integration",
      "description": "Facilitates interaction with Zapier for checking API status, configuring AI Actions, listing and executing actions, and retrieving execution logs. This skill provides a comprehensive set of actions to integrate and automate tasks with Zapier, enabling dynamic interaction with various applications and services. Example actions: Gmail: Send Email, Telegram: Send Message, Google Calendar: Find Event, Google Calendar: Quick Add Event, Google Sheets: Create Spreadsheet, Discord: Send Channel Message.",      
      "content": "from typing import Optional\nfrom autogenstudio.zapierservice import ZapierService\n\nclass ZapierSkill:\n    def __init__(self):\n        \"\"\"Initializes the Zapier skill for Zapier actions.\n        IMPORTANT: This skill enables interaction with Zapier to check API status,\n        get configuration links, list exposed actions, execute actions, and retrieve execution logs.\n        \"\"\"\n\n    def zapier_api_check(self) -> str:\n        \"\"\"Tests that the API and auth are working.\"\"\"\n        return ZapierService.zapier_api_check()\n\n    def zapier_api_get_configuration_link(self) -> str:\n        \"\"\"Provides a link to configure more AI Actions.\"\"\"\n        return ZapierService.zapier_api_get_configuration_link()\n\n    def zapier_api_list_exposed_actions(self) -> str:\n        \"\"\"Lists all the currently exposed actions for the given account.\"\"\"\n        return ZapierService.zapier_api_list_exposed_actions()\n\n    def zapier_api_execute_action(self, exposed_app_action_id: str, action_parameters: str, preview_only: Optional[bool] = False) -> str:\n        \"\"\"Executes an action with parameters in the HTTP POST API call to Zapier.\n\n        Args:\n            exposed_app_action_id (str): Action ID found through zapier_api_list_exposed_actions.\n            action_parameters (str): Parameters for the action, structured as a JSON string.\n            preview_only (Optional[bool]): If the action should be previewed as a test.\n        \"\"\"\n        return ZapierService.zapier_api_execute_action(exposed_app_action_id, action_parameters, preview_only)\n\n    def zapier_api_execute_log(self, execution_log_id: str) -> str:\n        \"\"\"Gets the execution log for a given execution log id.\n\n        Args:\n            execution_log_id (str): Execution Log ID found through zapier_api_execute_action.\n        \"\"\"\n        return ZapierService.zapier_api_execute_log(execution_log_id)\n\n    def zapier_api_create_action(self, configuration_link: str, action_description: str) -> str:\n        \"\"\"Gives URL to create a new AI Action within Zapier API.\n\n        Args:\n            configuration_link (str): Configuration link for AI Actions setup.\n            action_description (str): Description of the action to be created.\n        \"\"\"\n        return ZapierService.zapier_api_create_action(configuration_link, action_description)\n",
      "examples": "import json\nfrom skills import ZapierSkill\n\n# Initialize the Zapier skill\nzapier_skill = ZapierSkill()\n\n# Example usage of zapier_api_check\napi_check_result = zapier_skill.zapier_api_check()\nprint('API Check Result:', api_check_result)\n\n# Example usage of zapier_api_get_configuration_link\n# Provides a link to configure more AI Actions.\nconfig_link = zapier_skill.zapier_api_get_configuration_link()\nprint('Configuration Link:', config_link)\n\n# Example usage of zapier_api_list_exposed_actions\n# Lists all the currently exposed actions for the given account.\nexposed_actions = zapier_skill.zapier_api_list_exposed_actions()\nprint('Exposed Actions:', exposed_actions)\n\n# Example usage of zapier_api_execute_action\n# Executes an action with parameters in the HTTP POST API call to Zapier.\n# Example action ID, found from exposed_actions\naction_id = '01ARZ3NDEKTSV4RRFFQ69G5FAV'\n\n# Example parameters as string of JSON key-value pairs\naction_params = {'Subject': 'just testing', 'Body': 'hello from bob', 'To': 'terry@gmail.com'}'\naction_params_json = json.dumps(naction_params)\nexecute_action_result = zapier_skill.zapier_api_execute_action(exposed_app_action_id=action_id, action_parameters=action_params_json, preview_only=False)\nprint('Execute Action Result:', execute_action_result)\n\n# Example usage of zapier_api_execute_log\n# Gets the execution log for a given execution log id.\n# Example execution log ID, found from execute_action_result\nexecution_log_id = 'example-log-id'\nexecution_log = zapier_skill.zapier_api_execute_log(execution_log_id=execution_log_id)\nprint('Execution Log:', execution_log)\n\n# Example usage of zapier_api_create_action\n# Gives URL to create a new AI Action within Zapier API.\n# fetched from zapier_api_get_configuration_link()\nconfiguration_link = config_link\naction_description = 'Gmail: Send Email'\ncreate_action_result = zapier_skill.zapier_api_create_action(configuration_link=configuration_link, action_description=action_description)\nprint('Create Action Result:', create_action_result)\n",
      "file_name": "zapier_integration.py"
    }
  ],
  "workflows": [
    {
      "name": "Travel Agent Group Chat Workflow",
      "description": "A group chat workflow",
      "type": "groupchat",
      "sender": {
        "type": "agent",
        "init_code": "agent = autogen.UserProxyAgent(path_to_oai_dir=oai_dir, **agent_spec.config.dict())",
        "config": {
          "name": "userproxy",
          "human_input_mode": "NEVER",
          "max_consecutive_auto_reply": 5,
          "system_message": "You are a helpful assistant. Read the history and terminate once done with a sufficient answer, don't terminate prematurely.",
          "default_auto_reply": "TERMINATE",
          "code_execution_config": {
            "work_dir": null,
            "use_docker": false,
            "executor": "commandline-local"
          }
        }
      },
      "receiver": {
        "type": "groupchat",
        "init_code": "agents = [self.load(self.sanitize_agent_spec(agent_spec_internal, session_id), session_id) for agent_spec_internal in agent_spec.groupchat_config.agents]\ngroup_chat_config = agent_spec.groupchat_config.dict()\ngroup_chat_config['agents'] = agents\ngroupchat = autogen.GroupChat(**group_chat_config)\nagent = autogen.GroupChatManager(groupchat=groupchat, path_to_oai_dir=oai_dir, **agent_spec.config.dict())",
        "config": {
          "name": "group_chat_manager",
          "llm_config": {
            "config_list": [
              {
                "model": "gpt-4-turbo-preview"
              }
            ],
            "temperature": 0.1,
            "timeout": 600,
            "cache_seed": 42
          },
          "human_input_mode": "NEVER",
          "system_message": "Group chat manager"
        },
        "groupchat_config": {
          "admin_name": "Admin",
          "max_round": 10,
          "speaker_selection_method": "auto",
          "agents": [
            {
              "type": "agent",
              "init_code": "agent = autogen.AssistantAgent(path_to_oai_dir=oai_dir, **agent_spec.config.dict())",
              "config": {
                "name": "travel_planner",
                "llm_config": {
                  "config_list": [
                    {
                      "model": "gpt-4-turbo-preview"
                    }
                  ],
                  "temperature": 0.1,
                  "timeout": 600,
                  "cache_seed": 42
                },
                "human_input_mode": "NEVER",
                "max_consecutive_auto_reply": 8,
                "system_message": "You are a helpful assistant that can suggest a travel plan for a user. You are the primary cordinator who will receive suggestions or advice from other agents (local_assistant, language_assistant). You must ensure that the finally plan integrates the suggestions from other agents or team members. YOUR FINAL RESPONSE MUST BE THE COMPLETE PLAN. Don't repeat responses. Ensure that each prompt or question is unique or add a variation if you need to reiterate a question. Reply with TERMINATE if you think the group is finished.",
                "default_auto_reply": "TERMINATE"
              }
            },
            {
              "type": "agent",
              "init_code": "agent = autogen.AssistantAgent(path_to_oai_dir=oai_dir, **agent_spec.config.dict())",
              "config": {
                "name": "local_assistant",
                "llm_config": {
                  "config_list": [
                    {
                      "model": "gpt-4-turbo-preview"
                    }
                  ],
                  "temperature": 0.1,
                  "timeout": 600,
                  "cache_seed": 42
                },
                "human_input_mode": "NEVER",
                "max_consecutive_auto_reply": 8,
                "system_message": "You are a helpful assistant in a group that can review travel plans, providing critical feedback on how the trip can be enriched for enjoyment of the local culture. If the plan already includes local experiences, you can mention that the plan is satisfactory, with rationale. Don't repeat responses. Ensure that each prompt or question is unique or add a variation if you need to reiterate a question. Reply with TERMINATE if you think the group is finished.",
                "default_auto_reply": "TERMINATE"
              }
            },
            {
              "type": "agent",
              "init_code": "agent = autogen.AssistantAgent(path_to_oai_dir=oai_dir, **agent_spec.config.dict())",
              "config": {
                "name": "language_assistant",
                "llm_config": {
                  "config_list": [
                    {
                      "model": "gpt-4-turbo-preview"
                    }
                  ],
                  "temperature": 0.1,
                  "timeout": 600,
                  "cache_seed": 42
                },
                "human_input_mode": "NEVER",
                "max_consecutive_auto_reply": 8,
                "system_message": "You are a helpful assistant that can review travel plans, providing feedback on important/critical tips about how best to address language or communication challenges for the given destination. If the plan already includes language tips, you can mention that the plan is satisfactory, with rationale. Don't repeat responses. Ensure that each prompt or question is unique or add a variation if you need to reiterate a question. Reply with TERMINATE if you think the group is finished.",
                "default_auto_reply": "TERMINATE"
              }
            }
          ]
        }
      }
    },
    {
      "name": "General Agent Workflow",
      "description": "This workflow is used for general purpose tasks.",
      "sender": {
        "type": "agent",
        "description": "A user proxy agent that executes code.",
        "init_code": "agent = autogen.UserProxyAgent(path_to_oai_dir=oai_dir, **agent_spec.config.dict())",
        "config": {
          "name": "userproxy",
          "human_input_mode": "NEVER",
          "max_consecutive_auto_reply": 10,
          "system_message": "You are a helpful assistant.",
          "default_auto_reply": "TERMINATE",
          "llm_config": false,
          "code_execution_config": {
            "work_dir": null,
            "use_docker": false,
            "executor": "commandline-local"
          }
        }
      },
      "receiver": {
        "type": "agent",
        "description": "Default assistant to generate plans and write code to solve tasks.",
        "init_code": "agent = autogen.AssistantAgent(path_to_oai_dir=oai_dir, **agent_spec.config.dict())",
        "skills": [
          {
            "title": "find_papers_arxiv",
            "description": "This skill finds relevant papers on arXiv given a query.",
            "content": "import os\nimport re\nimport json\nimport hashlib\n\n\ndef search_arxiv(query, max_results=10):\n    \"\"\"\n    Searches arXiv for the given query using the arXiv API, then returns the search results. This is a helper function. In most cases, callers will want to use 'find_relevant_papers( query, max_results )' instead.\n\n    Args:\n        query (str): The search query.\n        max_results (int, optional): The maximum number of search results to return. Defaults to 10.\n\n    Returns:\n        jresults (list): A list of dictionaries. Each dictionary contains fields such as 'title', 'authors', 'summary', and 'pdf_url'\n\n    Example:\n        >>> results = search_arxiv(\"attention is all you need\")\n        >>> print(results)\n    \"\"\"\n\n    import arxiv\n\n    key = hashlib.md5((\"search_arxiv(\" + str(max_results) + \")\" + query).encode(\"utf-8\")).hexdigest()\n    # Create the cache if it doesn't exist\n    cache_dir = \".cache\"\n    if not os.path.isdir(cache_dir):\n        os.mkdir(cache_dir)\n\n    fname = os.path.join(cache_dir, key + \".cache\")\n\n    # Cache hit\n    if os.path.isfile(fname):\n        fh = open(fname, \"r\", encoding=\"utf-8\")\n        data = json.loads(fh.read())\n        fh.close()\n        return data\n\n    # Normalize the query, removing operator keywords\n    query = re.sub(r\"[^\\s\\w]\", \" \", query.lower())\n    query = re.sub(r\"\\s(and|or|not)\\s\", \" \", \" \" + query + \" \")\n    query = re.sub(r\"[^\\s\\w]\", \" \", query.lower())\n    query = re.sub(r\"\\s+\", \" \", query).strip()\n\n    search = arxiv.Search(query=query, max_results=max_results, sort_by=arxiv.SortCriterion.Relevance)\n\n    jresults = list()\n    for result in search.results():\n        r = dict()\n        r[\"entry_id\"] = result.entry_id\n        r[\"updated\"] = str(result.updated)\n        r[\"published\"] = str(result.published)\n        r[\"title\"] = result.title\n        r[\"authors\"] = [str(a) for a in result.authors]\n        r[\"summary\"] = result.summary\n        r[\"comment\"] = result.comment\n        r[\"journal_ref\"] = result.journal_ref\n        r[\"doi\"] = result.doi\n        r[\"primary_category\"] = result.primary_category\n        r[\"categories\"] = result.categories\n        r[\"links\"] = [str(link) for link in result.links]\n        r[\"pdf_url\"] = result.pdf_url\n        jresults.append(r)\n\n    if len(jresults) > max_results:\n        jresults = jresults[0:max_results]\n\n    # Save to cache\n    fh = open(fname, \"w\")\n    fh.write(json.dumps(jresults))\n    fh.close()\n    return jresults\n",
            "examples": ""
          },
          {
            "title": "generate_images",
            "description": "This skill generates images from a given query using OpenAI's DALL-E model and saves them to disk.",
            "content": "from typing import List\nimport uuid\nimport requests  # to perform HTTP requests\nfrom pathlib import Path\n\nfrom openai import OpenAI\n\n\ndef generate_and_save_images(query: str, image_size: str = \"1024x1024\") -> List[str]:\n    \"\"\"\n    Function to paint, draw or illustrate images based on the users query or request. Generates images from a given query using OpenAI's DALL-E model and saves them to disk.  Use the code below anytime there is a request to create an image.\n\n    :param query: A natural language description of the image to be generated.\n    :param image_size: The size of the image to be generated. (default is \"1024x1024\")\n    :return: A list of filenames for the saved images.\n    \"\"\"\n\n    client = OpenAI()  # Initialize the OpenAI client\n    response = client.images.generate(model=\"dall-e-3\", prompt=query, n=1, size=image_size)  # Generate images\n\n    # List to store the file names of saved images\n    saved_files = []\n\n    # Check if the response is successful\n    if response.data:\n        for image_data in response.data:\n            # Generate a random UUID as the file name\n            file_name = str(uuid.uuid4()) + \".png\"  # Assuming the image is a PNG\n            file_path = Path(file_name)\n\n            img_url = image_data.url\n            img_response = requests.get(img_url)\n            if img_response.status_code == 200:\n                # Write the binary content to a file\n                with open(file_path, \"wb\") as img_file:\n                    img_file.write(img_response.content)\n                    print(f\"Image saved to {file_path}\")\n                    saved_files.append(str(file_path))\n            else:\n                print(f\"Failed to download the image from {img_url}\")\n    else:\n        print(\"No image data found in the response!\")\n\n    # Return the list of saved files\n    return saved_files\n\n\n# Example usage of the function:\n# generate_and_save_images(\"A cute baby sea otter\")\n",
            "examples": ""
          }
        ],
        "config": {
          "name": "primary_assistant",
          "llm_config": {
            "config_list": [
              {
                "model": "gpt-4-1106-preview"
              }
            ],
            "temperature": 0.1,
            "timeout": 600,
            "cache_seed": null
          },
          "human_input_mode": "NEVER",
          "max_consecutive_auto_reply": 15,
          "system_message": "You are a helpful AI assistant. Solve tasks using your coding and language skills. In the following cases, suggest python code (in a python coding block) or shell script (in a sh coding block) for the user to execute. 1. When you need to collect info, use the code to output the info you need, for example, browse or search the web, download/read a file, print the content of a webpage or a file, get the current date/time, check the operating system. After sufficient info is printed and the task is ready to be solved based on your language skill, you can solve the task by yourself. 2. When you need to perform some task with code, use the code to perform the task and output the result. Finish the task smartly. Solve the task step by step if you need to. If a plan is not provided, explain your plan first. Be clear which step uses code, and which step uses your language skill. When using code, you must indicate the script type in the code block. The user cannot provide any other feedback or perform any other action beyond executing the code you suggest. The user can't modify your code. So do not suggest incomplete code which requires users to modify. Don't use a code block if it's not intended to be executed by the user. If you want the user to save the code in a file before executing it, put # filename: <filename> inside the code block as the first line. Don't include multiple code blocks in one response. Do not ask users to copy and paste the result. Instead, use 'print' function for the output when relevant. Check the execution result returned by the user. If the result indicates there is an error, fix the error and output the code again. Suggest the full code instead of partial code or code changes. If the error can't be fixed or if the task is not solved even after the code is executed successfully, analyze the problem, revisit your assumption, collect additional info you need, and think of a different approach to try. When you find an answer, verify the answer carefully. Include verifiable evidence in your response if possible. Reply 'TERMINATE' in the end when everything is done."
        }
      },
      "type": "twoagents"
    }
  ]
}
